# 复盘 replay

**拉勾**

- spring bean（单例）的生命周期？
- 脑裂，分区
- hashmap put操作
- 快速排序
- 冒泡排序
- mysql 数据库命令
- 线程池原理，创建线程需要有哪些参数
- 线程状态
- redis 源码实现
- 聚簇索引

**滴滴**

- stirng 字符串 是否包含制定的字符串 `contains()`方法，源码实现
- KMP算法，字符串匹配
- BF算法

**算法**

- Collections sort 方法 、 Array sort 方法 string sort排序
- 两个集合排序求并集，有重复的数据
- 中位数
- 二叉树、二叉搜索树

**支付宝**

- string
- synchronized 底层实现，怎么做的监听,Monitor是怎么做的，c++层面
- mysql mvvc 版本控制
- java对象在jvm中是怎么存放的
- Java中的偏向锁，轻量级锁， 重量级锁解析
- Klass-Oop
- Thread方法，wait和notify为啥不放在Thread里边
- ThreadLocal用到哪儿了，会导致内存溢出吗
- 线程池的个数设多大合适
- 指令重排序解决了哪些问题
- spring cloud feign 做了哪些配置
- spring cloud ribbon 做的配置
- spring cloud 熔断器 做的配置
- es的底层结构，为什么查的快
- es的数据结构，scheme设计，es的数据类型有哪些
- java线程中断，线程怎么停止，为什么不用stop

**快手**

- nginx 的底层 与 netty的底层，对比来说，各有什么优缺点
- epool和pool，还有其他的吗，原理是什么
- 判断平衡树算法
- 跳跃表与红黑树对比，redis为什么选跳跃表

**清单**

- Thread源码中有running状态吗
- for循环删除有什么问题
- for循环删除偶数位置的元素
- 设计模式的六个原则，依赖倒置原则
- java的内存区域
- ThreadService源码 worker
- Java8的新特性
- mysql group by having 的用法
- Spring IOC有什么好处？https://blog.csdn.net/weixin_40423553/article/details/80061881
- 函数式编程与面向对象
- java对象从加载到创建它是如何在内存中运转的
- Netty的bytebuffer源码了解吗
- redis键的长度不能超过多少
- 分布式服务调用操作数据库保证一致性
- mybatis 的二级缓存和三级缓存
- mybatis的懒加载
- http 的get和post本质区别
- https://www.cnblogs.com/justcooooode/p/7603381.html
- https://www.cnblogs.com/justcooooode/p/7514863.html
- hashmap  1.7  1.8区别
- mysql uuid索引结构与自增主键区别
- mysql  没有主键会怎样
- 多线程线程池拒绝策略
- xmpp  mqtt  区别
- concurrentmap  锁机制
- 进程与线程的区别，cpu如何抢占
- 端口监听状态
- spring mvc 工作流程
- 动态字节码
- spring循环依赖，怎么处理的
- 线程池的空闲时间是怎么实现的
- equals相等hashcode一定会相等吗
- 队列有哪些，阻塞poll的源码实现

**jd**

- hashmap 负载因子为什么是0.75
- 线程池的设计模式
- redis 跳跃表
- GC Root
- 熔断器  限流  降级  隔离
- lock 公平锁和非公平锁如何抢占，有什么区别吗
- 分布式任务
- 分布式事务

**latest**

- Redis内存淘汰策略
- redis 分布式锁漏洞
