# Golang

<!-- TOC -->

- [Golang](#golang)
  - [参考书](#参考书)
  - [数组](#数组)
  - [切片](#切片)
  - [映射](#映射)
  - [类型的本质](#类型的本质)
  - [包管理](#包管理)

<!-- /TOC -->

## 参考书

- 《Go语言实战》

A language needs only one conditional control flow construct.  
一种语言仅需要一个条件控制流构造。

## 数组


声明一个包含5个元素的整型数组
``` go
var array [5]int
```

声明一个包含5个元素的整型数组，用具体的值初始化每个元素
``` go

array := [5]int{10,20,30,40,50}

```

声明一个整型数组，用具体的值初始化每个元素，容量由初始化值的数量决定
``` go
array := [...]int{10,20,30,40,50}
```

声明一个包含5个元素的整型数组，用具体的值初始化索引为1和2的元素，其余元素保持零值

``` go
array := [5]int{1:10,2:20}
```

声明一个数据，修改索引为2的元素的值

``` go
array := [5]int{10,20,30,40,50}
array[2] = 35
```

## 切片

创建一个字符串切片，其长度和容量都是5个元素

``` go
slice := make([]string 5)
```

创建一个整型切片，其长度为3个元素，容量为5个元素
``` go
slice := make([]int,3,5)
```

**通过切片字面量来声明切片**

创建一个字符串切片，其长度和容量都是5个元素
``` go
slice := []string{"Red","Blue","Yello","Pink"}

```
创建一个整型切片，其长度和容量都是3个元素
``` go
slice := []int{10,20,30}
```


创建字符串切片，使用空字符串初始化第100个元素
``` go
slice := []string{99:""}
```

记住，如果在 `[]` 运算符里指定一个值，那么创建的就是数组而不是切片。只有不指定值的时候，才会创建切片。

**声明数组和切片的不同**

``` go
// 创建有3个元素的整型数组
array := [3]int{10,20,30}
// 创建长度和容量都是3的整型切片
slice := []int{10,20,30}
```

## 映射

**使用make声明映射**

创建一个映射，键的类型是string，值的类型是int
``` go
dict := make(map[string]int)
```
创建一个映射，键和值的类型都是string，使用两个键值对初始化映射

``` go
dict := map[string]string{"Red":"#da1337","Orange":"#e95a22"}
```

声明一个存储字符串切片的映射，使用字符串切面作为值
``` go
dict := map[int][]string{}
```


## 类型的本质

**内置类型**

- 数值类型
- 字符串类型
- 布尔类型

**引用类型**

- 切片
- 映射
- 通道
- 接口
- 函数类型

Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型
的变量时，创建的变量被称作标头（header）值。从技术细节上说，字符串也是一种引用类型。
每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特
的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用
类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是
在共享底层数据结构。


**结构类型**

结构类型可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。如
果决定在某些东西需要删除或者添加某个结构类型的值时该结构类型的值不应该被更改，那么需
要遵守之前提到的内置类型和引用类型的规范。

## 包管理

- Go Mod
- Go Vendor 
- Go dep
- Go Modules